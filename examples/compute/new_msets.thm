Define adj : list A -> A -> list A -> prop by
; adj L X (X :: L)
; adj (Y :: J) X (Y :: L) := adj J X L.

Suspend adj J _ L.

Theorem adj_swap[A] : forall (E F : A) (J K L : list A),
  adj J E K -> adj K F L ->
  exists U, adj J F U /\ adj U E L.
induction on 2. intros. case H2.
  search.
  case H1.
    search.
    apply IH to H4 H3. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Partially computational version

Define perm : list A -> list A -> prop by
; perm nil nil
; perm J1 K1 :=
    exists X J2 K2, adj J2 X J1 /\ adj K2 X K1 /\ perm J2 K2.

% Suspend perm J K.
Suspend perm J _.
Suspend perm _ K.

Theorem adj_det[A] : forall (X : A) (J1 J2 K1 K2 : list A),
  perm J1 J2 -> adj J1 X K1 -> adj J2 X K2 -> perm K1 K2.
induction on 1. intros. case H1.
  search.
  apply adj_swap to *H4 *H2. apply adj_swap to *H5 *H3.
    apply IH to *H6 H7 H9. search.

Seal Type mset with perm.

Define p : mset A -> prop by
  p (mset (A :: L)) := member A L.

Suspend p (mset L).

Kind i type.
Type a,b,c i.

Theorem test_ag1 : mset (a :: nil) = mset (b :: nil) -> false.
intros. compute H1.

Theorem test_ag2[A] : forall (X Y : A), mset (X :: nil) = mset (Y :: nil) -> X = Y.
intros. compute *H1. search.

Theorem test : p (mset (b :: a :: nil)) -> false.
intros. compute *H1.
  abort. % compute is often stuck

%% Theorems to get perm unstuck

Theorem perm_nil2[A] : forall (L : list A), perm L nil -> L = nil.
intros. case H1.
  search.
  case H3.
Theorem perm_nil1[A] : forall (L : list A), perm nil L -> L = nil.
intros. case H1.
  search.
  case H2.
Theorem perm_cons1[A] : forall (J L : list A) (E : A), perm (E :: J) L ->
  exists K, adj K E L /\ perm J K.
induction on 1. intros. case H1. case H2.
  search.
  apply IH to *H4. apply adj_swap to *H6 *H3. apply adj_det to *H7 *H5 *H8.
    search.
Theorem perm_cons2[A] : forall (J L : list A) (E : A), perm J (E :: L) ->
  exists K, adj K E J /\ perm K L.
induction on 1. intros. case H1. case H3.
  search.
  apply IH to *H4. apply adj_swap to *H6 *H2. apply adj_det to *H7 *H8 *H5.
    search.

Theorem test_modulo : p (mset (b :: a :: nil)) -> false.
intros. compute *H1 with perm_nil1, perm_nil2, perm_cons1, perm_cons2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% More computational, fewer rewrites, better async

Define perm2 : list A -> list A -> prop by
; perm2 nil nil
; perm2 (X :: J) K :=
    exists K1, adj K1 X K /\ perm2 J K1.

Suspend perm2 J _.

Theorem perm2_nil2[A] : forall (L : list A), perm2 L nil -> L = nil.
intros. case H1. search. case H2.

Theorem perm2_cons2[A] : forall (J L : list A) (E : A), perm2 J (E :: L) ->
  exists K, adj K E J /\ perm2 K L.
induction on 1. intros. case H1.
  compute H2. search.
  apply IH to *H3. search.

Seal Type mset2 with perm2.

Define p2 : mset2 A -> prop by
  p2 (mset2 (A :: L)) := member A L.

Suspend p2 (mset2 L).

Theorem test2 : p2 (mset2 (b :: a :: nil)) -> false.
intros. compute H1 with perm2_nil2, perm2_cons2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% New MLL

Kind atm, form type.
Type atm,natm  atm -> form.
Type tens, par form -> form -> form.
Type one, bot  form.

Define append : list A -> list A -> list A -> prop by
; append nil K K
; append (X :: J) K (X :: L) := append J K L.

Suspend append J _ K.

Type pp, qq atm.

Define mll : mset form -> prop by
; mll (mset (atm A :: natm A :: nil))
% ; mll (mset (one :: nil))
% ; mll (mset (bot :: L)) := mll (mset L)
; mll (mset (tens A B :: L)) :=
    exists J K, append J K L /\
    mll (mset (A :: J)) /\ mll (mset (B :: K))
; mll (mset (par A B :: L)) :=
    mll (mset (A :: B :: L)).

Suspend mll (mset L).

Theorem mll_fail_1 : forall A B, mll (mset (tens (atm A) (atm B) :: nil)) -> false.
intros. compute H1 with perm_nil1, perm_nil2, perm_cons1, perm_cons2.

Theorem mll_fail_2 : mll (mset (tens (atm pp) (natm qq) ::
                                tens (natm pp) (atm qq) :: nil)) -> false.
intros.
 % compute 5000 H1 with perm_nil1, perm_nil2, perm_cons1, perm_cons2.
 abort.

Define mll2 : mset2 form -> prop by
; mll2 (mset2 (atm A :: natm A :: nil))
% ; mll2 (mset2 (one :: nil))
% ; mll2 (mset2 (bot :: L)) := mll2 (mset2 L)
; mll2 (mset2 (tens A B :: L)) :=
    exists J K, append J K L /\
    mll2 (mset2 (A :: J)) /\ mll2 (mset2 (B :: K))
; mll2 (mset2 (par A B :: L)) :=
    mll2 (mset2 (A :: B :: L)).

Suspend mll2 (mset2 L).

Theorem mll2_fail_1 : forall A B, mll2 (mset2 (tens (atm A) (atm B) :: nil)) -> false.
intros. compute H1 with perm2_nil2, perm2_cons2.

Query 4 mll2 (mset2 (A :: B :: nil)).

Theorem mll2_fail_2 : mll2 (mset2 (tens (atm pp) (natm qq) ::
                                   tens (natm pp) (atm qq) :: nil)) -> false.
intros. compute H1 with perm2_nil2, perm2_cons2.

Theorem mll2_fail_3 : mll2 (mset2 (tens (atm pp) (atm qq) ::
                                   tens (atm pp) (natm qq) ::
                                   tens (natm pp) (atm qq) ::
                                   tens (natm pp) (natm qq) :: nil)) -> false.
intros.
  case H1.
    compute H2 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.
      compute H3.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H4 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
        compute H5 with perm2_nil2, perm2_cons2.
    compute H2 with perm2_nil2, perm2_cons2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Some meta-theorems

Theorem perm2_trans[A] : forall (J K L : list A), perm2 J K -> perm2 K L -> perm2 J L. skip.

Theorem mll2_perm : forall J K, perm2 J K -> mll2 (mset2 J) -> mll2 (mset2 K).
intros. case H2.
  apply perm2_trans to H3 H1. search.
  apply perm2_trans to H3 H1. search.
  apply perm2_trans to H3 H1. search.

Define dual : form -> form -> prop by
; dual (atm A) (natm A)
; dual (tens A B) (par Ad Bd) := dual A Ad /\ dual B Bd
% ; dual one bot
.

Theorem dual_det : forall A B C, dual A B -> dual A C -> B = C.
induction on 1. intros. case H1.
  case H2. search.
  case H2. apply IH to *H3 *H5. apply IH to *H4 *H6. search.

Theorem mll2_gid : forall A B, dual A B -> mll2 (mset2 (A :: B :: nil)).
induction on 1. intros. case H1.
  search.
  apply IH to *H2. apply IH to *H3.
    assert mll2 (mset2 (tens A1 Bd :: Ad :: Bd :: nil)). unfold 2. search.
    unfold 3. search.

Theorem mll2_cut : forall A B J K L, dual A B ->
  mll2 (mset2 (A :: J)) -> mll2 (mset2 (B :: K)) ->
  append J K L -> mll2 (mset2 L).
induction on 1. induction on 2. intros. case H1.
  case H2.
    compute *H5 *H4 with perm2_nil2, perm2_cons2. search.
    compute *H5. compute H10 with perm2_cons2.
