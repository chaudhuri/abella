Define adj : list A -> A -> list A -> prop by
; adj L X (X :: L)
; adj (Y :: J) X (Y :: L) := adj J X L.

Suspend adj J _ L.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Partially computational version

Define perm : list A -> list A -> prop by
; perm nil nil
; perm J1 K1 :=
    exists X J2 K2, adj J2 X J1 /\ adj K2 X K1 /\ perm J2 K2.

% Suspend perm J K.
Suspend perm J _.
Suspend perm _ K.

Seal Type mset with perm.

Define p : mset A -> prop by
  p (mset (A :: L)) := member A L.

Suspend p (mset L).

Kind i type.
Type a,b i.

Theorem test_ag1 : mset (a :: nil) = mset (b :: nil) -> false.
intros. compute H1.

Theorem test_ag2[A] : forall (X Y : A), mset (X :: nil) = mset (Y :: nil) -> X = Y.
intros. compute *H1. search.

Theorem test : p (mset (b :: a :: nil)) -> false.
intros. compute *H1.
  abort. % compute is often stuck

%% Theorems to get perm unstuck

Theorem perm_nil2[A] : forall (L : list A), perm L nil -> L = nil.
intros. case H1.
  search.
  case H3.
Theorem perm_nil1[A] : forall (L : list A), perm nil L -> L = nil.
intros. case H1.
  search.
  case H2.
Theorem perm_sing1[A] : forall (L : list A) (E : A), perm L (E :: nil) -> L = E :: nil.
intros. case H1. case H3.
  apply perm_nil2 to *H4. case H2. search.
  case H5.
Theorem perm_sing2[A] : forall (L : list A) (E : A), perm (E :: nil) L -> L = E :: nil.
intros. case H1. case H2.
  apply perm_nil1 to *H4. case H3. search.
  case H5.

Theorem test_modulo : p (mset (b :: a :: nil)) -> false.
intros. compute *H1 with perm_nil1, perm_nil2, perm_sing1, perm_sing2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fully computational version

Define perm2 : list A -> list A -> prop by
; perm2 nil nil
; perm2 (X :: J) (Y :: K) :=
    (X = Y /\ perm2 J K) \/
    (exists J1 K1, adj J1 Y J /\ adj K1 X K /\ perm2 J1 K1).

Suspend perm2 J K.

Seal Type mset2 with perm2.

Define p2 : mset2 A -> prop by
  p2 (mset2 (A :: L)) := member A L.

Suspend p2 (mset2 L).

Theorem test2 : p2 (mset2 (b :: a :: nil)) -> false.
intros. compute H1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% New MLL

Kind atm, form type.
Type atm,natm  atm -> form.
Type tens, par form -> form -> form.
Type one, bot  form.

Define append : list A -> list A -> list A -> prop by
; append nil K K
; append (X :: J) K (X :: L) := append J K L.

Suspend append J _ K.

Define mll : mset2 form -> prop by
; mll (mset2 (atm A :: natm A :: nil))
; mll (mset2 (one :: nil))
; mll (mset2 (bot :: L)) := mll (mset2 L)
; mll (mset2 (tens A B :: L)) :=
    exists J K, append J K L /\
    mll (mset2 (A :: J)) /\ mll (mset2 (B :: K))
; mll (mset2 (par A B :: L)) :=
    mll (mset2 (A :: B :: L)).

Suspend mll (mset2 L).


Theorem fail_1 : forall A B, mll (mset2 (tens (atm A) (atm B) :: nil)) -> false.
intros. compute H1.

Type pp, qq atm.

Query 4 mll (mset2 (A :: B :: nil)).

%% Query 100 mll (mset2 (tens (atm pp) (atm qq) ::
%%                       tens (atm pp) (natm qq) ::
%%                       tens (natm pp) (atm qq) ::
%%                       tens (natm pp) (natm qq) :: nil)).

%%% this is not currently working
Theorem fail_2 : mll (mset2 (tens (atm pp) (atm qq) ::
                             tens (atm pp) (natm qq) ::
                             tens (natm pp) (atm qq) ::
                             tens (natm pp) (natm qq) :: nil)) -> false.
intros.
  % compute H1.
  abort.
