Define adj : list A -> A -> list A -> prop by
; adj L X (X :: L)
; adj (Y :: J) X (Y :: L) := adj J X L.

Suspend adj J _ L.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Partially computational version

Define perm : list A -> list A -> prop by
; perm nil nil
; perm J1 K1 :=
    exists X J2 K2, adj J2 X J1 /\ adj K2 X K1 /\ perm J2 K2.

% Suspend perm J K.
Suspend perm J _.
Suspend perm _ K.

Seal Type mset with perm.

Define p : mset A -> prop by
  p (mset (A :: L)) := member A L.

Suspend p (mset L).

Kind i type.
Type a,b i.

Theorem perm_nil2[A] : forall (L : list A), perm L nil -> L = nil.
intros. case H1.
  search.
  case H3.
Theorem perm_nil1[A] : forall (L : list A), perm nil L -> L = nil.
intros. case H1.
  search.
  case H2.
Theorem perm_sing1[A] : forall (L : list A) (E : A), perm L (E :: nil) -> L = E :: nil.
intros. case H1. case H3.
  apply perm_nil2 to *H4. case H2. search.
  case H5.
Theorem perm_sing2[A] : forall (L : list A) (E : A), perm (E :: nil) L -> L = E :: nil.
intros. case H1. case H2.
  apply perm_nil1 to *H4. case H3. search.
  case H5.

Theorem test : p (mset (b :: a :: nil)) -> false.
intros.
  case H1. % compute on p/mset isn't yet implemented
  compute *H2 *H3 with perm_nil1, perm_nil2, perm_sing1, perm_sing2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fully computational version

Define perm2 : list A -> list A -> prop by
; perm2 nil nil
; perm2 (X :: J) (Y :: K) :=
    (X = Y /\ perm2 J K) \/
    (exists J1 K1, adj J1 Y J /\ adj K1 X K /\ perm2 J1 K1).

Suspend perm2 J K.

Seal Type mset2 with perm2.

Define p2 : mset2 A -> prop by
  p2 (mset2 (A :: L)) := member A L.

Suspend p2 (mset2 L).

Theorem test2 : p2 (mset2 (b :: a :: nil)) -> false.
intros.
  case H1. % compute on p2/mset2 not yet implemented
  compute H2 H3.
