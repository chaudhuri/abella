%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Result of Seal

Kind mset type -> type.

Type perm mset A -> mset A -> prop. %% our equivalence relation

Suspend perm S _.
Suspend perm _ S.

Theorem perm_refl[A] : forall (S : mset A), perm S S.
skip.

Theorem perm_sym[A] : forall (S T : mset A), perm S T -> perm T S.
skip.

Theorem perm_trans[A] : forall (S T U : mset A), perm S T -> perm T U -> perm S U.
skip.

Type mset_nil mset A -> prop.

Theorem mset_nil_exists[A]: exists (S : mset A), mset_nil S.
skip.

Theorem mset_nil_perm_stable[A]: forall (S T : mset A),
  perm S T -> mset_nil S -> mset_nil T.
skip.

Theorem mset_nil_deterministic[A]: forall (S T : mset A),
  mset_nil S -> mset_nil T -> perm S T.
skip.

Type adj mset A -> A -> mset A -> prop.

Suspend adj S _ _.
Suspend adj _ _ S.

Theorem adj_exists[A]: forall (E : A) (S : mset A),
  exists (T : mset A), adj S E T.
skip.

Theorem adj_perm_stable[A] : forall (E : A) (S1 T1 S2 T2 : mset A),
  perm S1 S2 -> perm T1 T2 ->
  adj S1 E T1 -> adj S2 E T2.
skip.

Theorem adj_perm_forward[A] : forall (E : A) (S1 T1 S2 : mset A),
  perm S1 S2 -> adj S1 E T1 -> exists T2, perm T1 T2 /\ adj S2 E T2.
skip.

Theorem adj_perm_backward[A] : forall (E : A) (S1 T1 T2 : mset A),
  perm T1 T2 -> adj S1 E T1 -> exists S2, perm S1 S2 /\ adj S2 E T2.
skip.

Theorem adj_deterministic[A] : forall (E : A) (S1 S2 T1 T2 : mset A),
  perm S1 S2 -> adj S1 E T1 -> adj S2 E T2 -> perm T1 T2.
skip.

Theorem adj_swap[A] : forall (E F : A) (S T U : mset A),
  adj S E T -> adj T F U -> exists V, adj S F V /\ adj V E U.
skip.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Below Seal

Define mset : list A -> mset A -> prop by
; mset nil S := mset_nil S
; mset (E :: L) S := exists T, adj T E S /\ mset L T.

Suspend mset L _.

Theorem mset_perm_stable[A] : forall (L : list A) (S T : mset A),
  perm S T ->
  mset L S -> mset L T.
induction on 2. intros. case H2.
  apply mset_nil_perm_stable to H1 *H3. search.
  apply adj_perm_backward to H1 *H3.
   apply IH to H5 H4. search.

Theorem mset_deterministic[A] : forall (L : list A) (S T : mset A),
  mset L S -> mset L T -> perm S T.
induction on 1. intros. case H1.
  case H2. backchain mset_nil_deterministic.
  case H2. apply IH to *H4 *H6.
   apply adj_perm_forward to *H7 *H3.
   apply adj_deterministic to _ *H9 *H5. backchain perm_refl.
   backchain perm_trans.

Define merge : mset A -> mset A -> mset A -> prop by
  merge S T U :=
     (mset nil S /\ mset nil T /\ mset nil U)
  \/ (exists E S1 U1, adj S1 E S /\ adj U1 E U /\ merge S1 T U1)
  \/ (exists E T1 U1, adj T1 E T /\ adj U1 E U /\ merge S T1 U1).

Theorem merge_perm_stable[A] : forall (S1 T1 U1 S2 T2 U2 : mset A),
  perm S1 S2 -> perm T1 T2 -> perm U1 U2 ->
  merge S1 T1 U1 -> merge S2 T2 U2.
induction on 4. intros. case H4. case H5.
  apply mset_perm_stable to H1 *H6.
   apply mset_perm_stable to H2 *H7.
   apply mset_perm_stable to H3 *H8.
   search.
  apply adj_perm_backward to _ *H6 with T1 = S1, T2 = S2.
   apply adj_perm_backward to _ *H7 with T1 = U1, T2 = U2.
   apply IH to _ _ _ H8. search.
  apply adj_perm_backward to _ *H6 with T1 = T1, T2 = T2.
   apply adj_perm_backward to _ *H7 with T1 = U1, T2 = U2.
   apply IH to _ _ _ H8. search.

Define append : list A -> list A -> list A -> prop by
; append nil K K
; append (X :: J) K (X :: L) := append J K L.

Suspend append J _ K.

Kind nat type.
Type zero, two, three, four nat.

Theorem test : forall S T U L,
  mset (zero :: two :: nil) S ->
  mset (three :: four :: nil) T ->
  append (zero :: two :: nil) (three :: four :: nil) L ->
  mset L U -> merge S T U.
intros.
  compute (*all).
  search 10.

Theorem test2 : forall S T,
  mset (zero :: two :: three :: nil) S ->
  mset (two :: zero :: three :: nil) T ->
  perm S T.
intros.
  compute (*all).
  apply mset_nil_deterministic to *H7 *H3.
  apply adj_deterministic to *H11 *H8 *H4.
  apply adj_swap to *H5 *H6.
  apply adj_deterministic to *H12 *H9 *H13.
  apply adj_deterministic to *H15 *H10 *H14.
  search.

Kind atm, form type.
Type atm, natm atm -> form.
Type tens, par form -> form -> form.
Type one, bot  form.

Define $form : form -> prop by
; $form (atm A)
; $form (natm A)
; $form (tens F G) := $form F /\ $form G
; $form one
; $form (par F G) := $form F /\ $form G
; $form bot.

Define $ctx_list : list form -> prop by
; $ctx_list nil
; $ctx_list (F :: L) := $form F /\ $ctx_list L.

Define $ctx : mset form -> prop by
  $ctx GG := exists L, mset L GG /\ $ctx_list L.

Define dual : form -> form -> prop by
; dual (atm A) (natm A)
; dual (natm A) (atm A)
; dual (tens F G) (par Fd Gd) := dual F Fd /\ dual G Gd
; dual (par F G) (tens Fd Gd) := dual F Fd /\ dual G Gd
; dual one bot
; dual bot one.

Theorem dual_sym : forall F G, dual F G -> dual G F.
induction on 1. intros. case H1.
  search.
  search.
  apply IH to *H2. apply IH to *H3. search.
  apply IH to *H2. apply IH to *H3. search.
  search.
  search.

Theorem dual_idemp : forall F G H, dual F G -> dual G H -> F = H.
induction on 1. intros. case H1.
  case H2. search.
  case H2. search.
  case H2. apply IH to *H3 *H5. apply IH to *H4 *H6. search.
  case H2. apply IH to *H3 *H5. apply IH to *H4 *H6. search.
  case H2. search.
  case H2. search.

Define mll : mset form -> prop by
; mll GG := exists A, mset (atm A :: natm A :: nil) GG
; mll GG := mset (one :: nil) GG
; mll GG := exists L, mset (bot :: L) GG /\
            exists DD, mset L DD /\ mll DD
; mll GG := exists L A B, mset (tens A B :: L) GG /\
            exists L1 L2, append L1 L2 L /\
            exists DD1, mset (A :: L1) DD1 /\
            exists DD2, mset (B :: L2) DD2 /\
            mll DD1 /\ mll DD2
; mll GG := exists L A B, mset (par A B :: L) GG /\
            exists DD, mset (A :: B :: L) DD /\ mll DD
.

Theorem example : forall A B GG, mset (tens (atm A) (atm B) :: par (natm A) (natm B) :: nil) GG -> mll GG.
intros.
  unfold 5. witness (tens (atm A) (atm B) :: nil). witness (natm A). witness (natm B).
   split. compute *H1. apply adj_swap to *H3 *H4. search.
   assert exists GG1, mset (natm A :: natm B :: tens (atm A) (atm B) :: nil) GG1.
     %% this should be a witness compute
     apply mset_nil_exists.
     apply adj_exists with E = tens (atm A) (atm B), S = S.
     apply adj_exists with E = natm B, S = T.
     apply adj_exists with E = natm A, S = T1.
     search. case H2.
   witness GG1. split. search.
  unfold 4. witness (natm A :: natm B :: nil). witness (atm A). witness (atm B).
   split. compute *H3. apply adj_swap to *H5 *H6. apply adj_swap to *H9 *H7. search.
   assert exists GG2, mset (natm A :: nil) GG2.
     %% this should be a witness compute
     apply mset_nil_exists.
     apply adj_exists with E = natm A, S = S.
     search. case H4.
   witness natm A :: nil.
   assert exists GG3, mset (natm B :: nil) GG3.
     %% this should be a witness compute
     apply mset_nil_exists.
     apply adj_exists with E = natm B, S = S.
     search. case H6.
   witness (natm B :: nil). split. search.
   assert exists GG4, mset (atm A :: natm A :: nil) GG4.
     apply adj_exists with E = atm A, S = GG2. compute *H5. search. case H8.
   witness GG4. split. search.
   assert exists GG5, mset (atm B :: natm B :: nil) GG5.
     apply adj_exists with E = atm B, S = GG3. compute *H7. search. case H10.
   witness GG5. split. search.
   search. search.
