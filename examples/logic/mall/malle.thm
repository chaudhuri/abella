%%% Meta-theory of focused propositional MALL

Kind nat type.
Type z nat.
Type s nat -> nat.

Define is_nat : nat -> prop by
  is_nat z
; is_nat (s X) := is_nat X.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntax

Kind fm,atm type.

% An infinite set of candidate atoms
Type a,b,c,d,p,q          atm.        % for convenience
Type $atm                 nat -> atm.

Type patm                 atm -> fm.
Type tens,plus            fm -> fm -> fm.
Type one,zero             fm.

Type natm                 atm -> fm.
Type par,wth              fm -> fm -> fm.
Type bot,top              fm.

Define
  is_pos : fm -> prop
, is_neg : fm -> prop by

; is_pos (patm A)
; is_pos (tens P Q)
; is_pos one
; is_pos (plus P Q)
; is_pos zero

; is_neg (natm A)
; is_neg (par M N)
; is_neg bot
; is_neg (wth M N)
; is_neg top.

Define dual : fm -> fm -> prop by
; dual (patm A) (natm A)
; dual (tens P Q) (par M N)  := dual P M /\ dual Q N
; dual one bot
; dual (plus P Q) (wth M N)  := dual P M /\ dual Q N
; dual zero top.

Theorem $dual_det :
   (forall P Q N, dual P N -> dual Q N -> P = Q)
/\ (forall P M N, dual P M -> dual P N -> M = N).
induction on 1 1. split.
intros. case H1.
  case H2. search with =.
  case H2. apply IH to *H3 *H5. apply IH to *H4 *H6. search with =.
  case H2. search with =.
  case H2. apply IH to *H3 *H5. apply IH to *H4 *H6. search with =.
  case H2. search with =.
intros. case H1.
  case H2. search with =.
  case H2. apply IH1 to *H3 *H5. apply IH1 to *H4 *H6. search with =.
  case H2. search with =.
  case H2. apply IH1 to *H3 *H5. apply IH1 to *H4 *H6. search with =.
  case H2. search with =.

Split $dual_det as dual_det1, dual_det2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Formula multisets

% An injector that lets reuse the olist type for lists of formulas
Type $fm fm -> o.

Define divide : olist -> olist -> olist -> prop by
  divide L L1 L2 :=
    forall E M N, membern E M L1 -> membern E N L2 -> exists K, sum M N K /\ membern E K L.

% A concrete version of divide to be used with backchaining
Define merge : olist -> olist -> olist -> prop by
  merge nil nil nil
; merge (A :: L1) L2 (A :: K) := merge L1 L2 K
; merge L1 (A :: L2) (A :: K) := merge L1 L2 K.

Theorem merge_nil1 : forall L K, merge nil L K -> L = K.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Theorem merge_nil2 : forall L K, merge L nil K -> L = K.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Define membern : o -> nat -> olist -> prop by
  membern A z nil
; membern A (s X) (A :: L) := membern A X L
; membern A X (B :: L) := (A = B -> false) /\ membern A X L.

Theorem membern_nat : forall E N L, membern E N L -> is_nat N.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.
  apply IH to H3. search.

Theorem part_prune : forall L1 L2 L, nabla (x:nat),
  merge (L1 x) (L2 x) L ->
  exists L1' L2', (L1 = x\ L1') /\ (L2 = x\ L2').
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.
  apply IH to H2. search.

Theorem merge_incl1 : forall L1 L2 L E,
  merge L1 L2 L -> member E L1 -> member E L.
induction on 1. intros. case H1.
  case H2.
  case H2. search.
    apply IH to H3 H4. search.
  apply IH to H3 H2. search.

Theorem merge_incl2 : forall L1 L2 L E,
  merge L1 L2 L -> member E L2 -> member E L.
induction on 1. intros. case H1.
  case H2.
  apply IH to H3 H2. search.
  case H2. search.
    apply IH to H3 H4. search.

Define sum : nat -> nat -> nat -> prop by
  sum z N N
; sum (s M) N (s K) := sum M N K.

Theorem sum_z : forall M, is_nat M -> sum M z M.
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Theorem sum_s : forall M N K, sum M N K -> sum M (s N) (s K).
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Theorem sum_comm : forall M N K, is_nat N -> sum M N K -> sum N M K.
induction on 2. intros. case H2.
  backchain sum_z.
  backchain sum_s. backchain IH.

Theorem merge_membern : forall E M L1 N L2 L K,
  membern E M L1 ->
  membern E N L2 ->
  merge L1 L2 L ->
  membern E K L ->
  sum M N K.
induction on 3. intros. case H3.
  case H1. case H2. case H4. search.
  case H1.
    case H4. apply IH to H6 H2 H5 H7. search.
      apply H7 to _.
    case H4. apply H6 to _.
      apply IH to H7 H2 H5 H9. search.
  case H2.
    case H4. backchain sum_s. backchain IH.
      apply H7 to _.
    case H4. apply H6 to _.
      backchain IH.

Theorem merge_sum : forall E M L1 N L2 L K,
  membern E M L1 ->
  membern E N L2 ->
  merge L1 L2 L ->
  sum M N K ->
  membern E K L.
induction on 3. intros. case H3.
  case H1. case H2. case H4. search.
  case H1.
    case H4. unfold 2. apply IH to H6 H2 H5 H7. search.
    unfold 3. search. apply IH to H7 H2 H5 H4. search.
  case H2.
    apply membern_nat to H6. apply sum_comm to _ H4. case H8.
     unfold 2. apply membern_nat to H1. apply sum_comm to _ H9.
     apply IH to H1 H6 H5 H11. search.
    unfold 3. search. apply IH to H1 H7 H5 H4. search.

Theorem merge_count : forall E M L1 N L2 L,
   membern E M L1 ->
   membern E N L2 ->
   merge L1 L2 L ->
   exists K, sum M N K /\ membern E K L.
induction on 3. intros. case H3.
  case H1. case H2. search.
  case H1. apply IH to H5 H2 H4. witness s K1. search.
    apply IH to H6 H2 H4. witness K1. search.
  case H2. apply IH to H1 H5 H4. witness s K1. split. backchain sum_s. search.
    apply IH to H1 H6 H4. search.

Theorem merge_divide : forall L1 L2 L,
  merge L1 L2 L -> divide L L1 L2.
intros. unfold. intros. apply merge_count to H2 H3 H1. search.

Theorem membern_det2 : forall E N1 N2 L,
  membern E N1 L ->
  membern E N2 L ->
  N1 = N2.
induction on 1. intros. case H1.
  case H2. search.
  case H2. apply IH to H3 H4. search.
  apply H4 to _.
  case H2. apply H3 to _. apply IH to H4 H6. search.

Theorem divide_membern : forall E M L1 N L2 L K,
  membern E M L1 ->
  membern E N L2 ->
  divide L L1 L2 ->
  membern E K L ->
  sum M N K.
intros. case H3. apply H5 to H1 H2.
  apply membern_det2 to H4 H7. search.

Theorem sum_det2 : forall M N1 N2 K,
  sum M N1 K ->
  sum M N2 K ->
  N1 = N2.
induction on 1. intros. case H1.
  case H2. search.
  case H2. backchain IH.

Theorem sum_det3 : forall M N K1 K2,
  sum M N K1 ->
  sum M N K2 ->
  K1 = K2.
induction on 1. intros. case H1.
  case H2. search.
  case H2. apply IH to H3 H4. search.

Theorem divide_sum : forall E M L1 N L2 L K,
  membern E M L1 ->
  membern E N L2 ->
  divide L L1 L2 ->
  sum M N K ->
  membern E K L.
intros. case H3. apply H5 to H1 H2.
  apply sum_det3 to H4 H6. search.

Define remove : olist -> fm -> olist -> prop by
  remove L F K := divide L ($fm F :: nil) K.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% MALL rules

Define seq : olist -> prop by
; seq L := exists A, divide L ($fm (natm A) :: nil) ($fm (patm A) :: nil)
; seq L := exists L1 L2 L12 P Q, remove L (tens P Q) L12 /\ divide L12 L1 L2 /\
             seq ($fm P :: L1) /\ seq ($fm Q :: L2)
; seq L := L = $fm one :: nil
; seq L := exists L1 P Q, remove L (plus P Q) L1 /\ seq ($fm P :: L1)
; seq L := exists L1 P Q, remove L (plus P Q) L1 /\ seq ($fm Q :: L1)
; seq L := exists L1 M N, remove L (par M N) L1 /\ seq ($fm M :: $fm N :: L1)
; seq L := exists L1, remove L bot L1 /\ seq L1
; seq L := exists L1 M N, remove L (wth M N) L1 /\ seq ($fm M :: L1) /\ seq ($fm N :: L1)
; seq L := exists L1, remove L top L1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Identity reduction

Theorem id : forall F G, dual F G -> seq ($fm F :: $fm G :: nil).
induction on 1. intros. case H1.
  unfold 1. witness A. backchain merge_divide.
  unfold 6. witness $fm (tens P Q) :: nil. witness M. witness N. split.
    unfold. backchain merge_divide.
    unfold 2. witness $fm M :: nil. witness $fm N :: nil. witness $fm M :: $fm N :: nil.
     witness P. witness Q. split.
      unfold. backchain merge_divide.
      backchain merge_divide.
      backchain IH. backchain IH.
   unfold 7. witness $fm one :: nil. split.
     unfold. backchain merge_divide.
     search.
   unfold 8. witness $fm (plus P Q) :: nil. witness M. witness N. split.
     unfold. backchain merge_divide.
     unfold 4. witness $fm M :: nil. witness P. witness Q. split.
       unfold. backchain merge_divide.
       backchain IH.
     unfold 5. witness $fm N :: nil. witness P. witness Q. split.
       unfold. backchain merge_divide.
       backchain IH.
   unfold 9. witness $fm zero :: nil. unfold. backchain merge_divide.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cut-elimination

Theorem cut : forall P N L1 L2 K1 K2,
  dual P N ->
  seq L1 -> remove L1 P K1 ->
  seq L2 -> remove L2 N K2 ->
  exists K, divide K K1 K2 /\ seq K.
RH : induction on 1. HH : induction on 2. intros.
