%%% Meta-theory of focused propositional MALL

Kind nat type.
Type z nat.
Type s nat -> nat.

Define is_nat : nat -> prop by
  is_nat z
; is_nat (s X) := is_nat X.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Syntax

Kind fm,atm type.

% An infinite set of candidate atoms
Type a,b,c,d,p,q          atm.        % for convenience
Type $atm                 nat -> atm.

Type patm                 atm -> fm.
Type tens,plus            fm -> fm -> fm.
Type one,zero             fm.

Type natm                 atm -> fm.
Type par,wth              fm -> fm -> fm.
Type bot,top              fm.

Define
  is_pos : fm -> prop
, is_neg : fm -> prop by

; is_pos (patm A)
; is_pos (tens P Q)
; is_pos one
; is_pos (plus P Q)
; is_pos zero

; is_neg (natm A)
; is_neg (par M N)
; is_neg bot
; is_neg (wth M N)
; is_neg top.

Define dual : fm -> fm -> prop by
; dual (patm A) (natm A)
; dual (tens P Q) (par M N)  := dual P M /\ dual Q N
; dual one bot
; dual (plus P Q) (wth M N)  := dual P M /\ dual Q N
; dual zero top.

Theorem $dual_det :
   (forall P Q N, dual P N -> dual Q N -> P = Q)
/\ (forall P M N, dual P M -> dual P N -> M = N).
induction on 1 1. split.
intros. case H1.
  case H2. search with =.
  case H2. apply IH to *H3 *H5. apply IH to *H4 *H6. search with =.
  case H2. search with =.
  case H2. apply IH to *H3 *H5. apply IH to *H4 *H6. search with =.
  case H2. search with =.
intros. case H1.
  case H2. search with =.
  case H2. apply IH1 to *H3 *H5. apply IH1 to *H4 *H6. search with =.
  case H2. search with =.
  case H2. apply IH1 to *H3 *H5. apply IH1 to *H4 *H6. search with =.
  case H2. search with =.

Split $dual_det as dual_det1, dual_det2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Formula multisets

% An injector that lets reuse the olist type for lists of formulas
Type $fm fm -> o.

Define partition : olist -> olist -> olist -> prop by
  partition nil nil nil
; partition (A :: L1) L2 (A :: K) := partition L1 L2 K
; partition L1 (A :: L2) (A :: K) := partition L1 L2 K.

Theorem part_prune : forall L1 L2 L, nabla (x:nat),
  partition (L1 x) (L2 x) L ->
  exists L1' L2', (L1 = x\ L1') /\ (L2 = x\ L2').
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.
  apply IH to H2. search.

Theorem partition_incl1 : forall L1 L2 L E,
  partition L1 L2 L -> member E L1 -> member E L.
induction on 1. intros. case H1.
  case H2.
  case H2. search.
    apply IH to H3 H4. search.
  apply IH to H3 H2. search.

Theorem partition_incl2 : forall L1 L2 L E,
  partition L1 L2 L -> member E L2 -> member E L.
induction on 1. intros. case H1.
  case H2.
  apply IH to H3 H2. search.
  case H2. search.
    apply IH to H3 H4. search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% MALL rules

Define
  seq : olist -> prop,
  rule : olist -> fm -> prop by

; seq L := exists K F, partition K ($fm F :: nil) L /\ rule K F

; rule ($fm (natm A) :: nil) (patm A)

; rule K (tens F G) :=
    exists K1 K2, partition K1 K2 K /\ seq ($fm F :: K1) /\ seq ($fm G :: K2)
; rule nil one
; rule K (plus F G) := seq ($fm F :: K)
; rule K (plus F G) := seq ($fm G :: K)

; rule K (par F G) := seq ($fm F :: $fm G :: K)
; rule K bot := seq K
; rule K (wth F G) := seq ($fm F :: K) /\ seq ($fm G :: K)
; rule K top
.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Identity reduction

Theorem id : forall F G, dual F G -> seq ($fm F :: $fm G :: nil).
induction on 1. intros. case H1.
  unfold 1. witness $fm (natm A) :: nil. search.
  unfold 1. witness $fm (tens P Q) :: nil. witness par M N. split. search.
    unfold. unfold. witness $fm M :: $fm N :: nil. witness tens P Q.
    apply IH to H2. apply IH to H3. search.
  search.
  apply IH to H2. apply IH to H3. unfold.
    witness $fm (plus P Q) :: nil. witness wth M N. split. search. unfold.
      search.
      search.
  search.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Cut-elimination

Theorem cut :
   (forall P N L1 L2 K1 K2,
      dual P N ->
      seq L1 -> partition K1 ($fm P :: nil) L1 ->
      seq L2 -> partition K2 ($fm N :: nil) L2 ->
      exists K, partition K1 K2 K /\ seq K)
/\ (forall P N L1 L2 K1 K2 F,
      dual P N ->
      rule L1 F -> partition K1 ($fm P :: nil) L1 ->
      seq L2 -> partition K2 ($fm N :: nil) L2 ->
      exists K, partition K1 K2 K /\ rule K F).
RIH1 : induction on 1 1. HIH1 : induction on 2 2. split.
intros. case H3. case H2.